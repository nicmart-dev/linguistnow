{
  "name": "Determine Google Calendar availability",
  "nodes": [
    {
      "parameters": {
        "content": "## Get calendar availability\n### Find free times using Google Calendar API",
        "height": 456,
        "width": 2237
      },
      "id": "5a4d7cd7-e873-4248-86f4-eed89f6ac839",
      "name": "Sticky Note2",
      "type": "n8n-nodes-base.stickyNote",
      "position": [848, 464],
      "typeVersion": 1
    },
    {
      "parameters": {
        "jsCode": "// Optimized: Process input efficiently without unnecessary loops\nconst inputItems = $input.all();\n\n// Validate input\nif (!inputItems || inputItems.length === 0) {\n    throw new Error('No input items received');\n}\n\n// Process the first item (webhook typically sends one item)\nconst item = inputItems[0];\n\n// Validate structure\nif (!item.json || !item.json.body) {\n    throw new Error('Invalid input structure: missing body');\n}\n\nif (!item.json.body.calendarIds) {\n    throw new Error('calendarIds is missing in the request body');\n}\n\n// Parse calendar IDs efficiently\nconst calendarIdsString = String(item.json.body.calendarIds).trim();\nif (!calendarIdsString) {\n    throw new Error('calendarIds is empty');\n}\n\n// Split and map in one operation for efficiency\nconst parsedCalendarIds = calendarIdsString\n    .split(',')\n    .map(id => id.trim())\n    .filter(id => id.length > 0)\n    .map(id => ({ id }));\n\nif (parsedCalendarIds.length === 0) {\n    throw new Error('No valid calendar IDs found after parsing');\n}\n\n// Stringify once\nitem.json.body.parsedCalendarIds = JSON.stringify(parsedCalendarIds);\n\n// Return the processed item\nreturn [item];\n"
      },
      "id": "27a42683-9280-4552-8a27-10f56983f1dc",
      "name": "Stringify calendar list",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [928, 592]
    },
    {
      "parameters": {
        "content": "## Get linguist calendars\n### Get list of calendar ids set by user as well as their Google access token",
        "height": 460.0809602854765,
        "width": 337.51818523945883
      },
      "id": "7fc0a253-7153-4bd8-a6d0-463ef1de841d",
      "name": "Sticky Note",
      "type": "n8n-nodes-base.stickyNote",
      "position": [464, 464],
      "typeVersion": 1
    },
    {
      "parameters": {
        "jsCode": "// Use time window defined previously\nconst timeMin = new Date($node[\"Define time window\"].json[\"timeMin\"]);\nconst timeMax = new Date($node[\"Define time window\"].json[\"timeMax\"]);\n\n// Get the combined availability from the previous node\nconst combinedAvailability = $input.all().map(item => item.json);\n\n// Sort combined availability by start time (if not already sorted)\ncombinedAvailability.sort((a, b) => new Date(a.start) - new Date(b.start));\n\n// Initialize an array to store free time slots\nconst freeSlots = [];\n\n// Find free slots between busy times\nlet lastEnd = timeMin;\nfor (const slot of combinedAvailability) {\n    const start = new Date(slot.start);\n    const end = new Date(slot.end);\n    \n    if (lastEnd < start) {\n        freeSlots.push({ start: lastEnd.toISOString(), end: start.toISOString() });\n    }\n    lastEnd = end > lastEnd ? end : lastEnd;\n}\n\n// Add the final free slot if there's free time until timeMax\nif (lastEnd < timeMax) {\n    freeSlots.push({ start: lastEnd.toISOString(), end: timeMax.toISOString() });\n}\n\n// Return the free slots\nreturn freeSlots.map(slot => ({ json: slot }));\n"
      },
      "id": "f9649888-a38d-4937-963a-a71eaaec4357",
      "name": "Return free time slots",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2256, 528]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://www.googleapis.com/calendar/v3/freeBusy",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "=Bearer {{ $('Fetch Token from Vault').item.json.data.accessToken }}"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"timeMin\": \"{{ $('Define time window').item.json[\"timeMin\"] }}\",\n  \"timeMax\": \"{{ $('Define time window').item.json[\"timeMax\"] }}\",\n  \"items\": \n   {{ $('Stringify calendar list').item.json[\"body\"][\"parsedCalendarIds\"] }}\n  \n}",
        "options": {}
      },
      "id": "42cb7764-11a9-4996-b3e4-db182dc55395",
      "name": "Check when busy",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [1872, 592]
    },
    {
      "parameters": {
        "jsCode": "// Initialize an empty array to store the combined availability\nconst combinedAvailability = [];\n\n// Loop over all input items\nfor (const calendar of $input.all()) {\n    // Get the calendars object from the current item's JSON\n    const calendars = calendar.json.calendars;\n\n    // Loop over each calendar in the calendars object\n    for (const calendarId in calendars) {\n        if (calendars.hasOwnProperty(calendarId)) {\n            // Get the busy slots array from the current calendar\n            const busySlots = calendars[calendarId].busy;\n\n            // Loop over each busy slot in the busy slots array\n            for (const slot of busySlots) {\n                // Extract start and end times from the busy slot\n                const { start, end } = slot;\n\n                // Push the busy slot to the combined availability array\n                combinedAvailability.push({ start, end });\n            }\n        }\n    }\n}\n\n// Sort combined availability by start time\ncombinedAvailability.sort((a, b) => new Date(a.start) - new Date(b.start));\n\n// Return the combined availability\nreturn combinedAvailability;\n"
      },
      "id": "84fe5044-b7cb-4544-97e8-a8f3ee3e5486",
      "name": "List when busy across all calendars",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2080, 720],
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "jsCode": "// Initialize an array to store the filtered free slots\nconst filteredFreeSlots = [];\n\n// Function to check if a date is a weekend\nfunction isWeekend(date) {\n    const day = date.getDay();\n    return day === 0 || day === 6; // Sunday or Saturday\n}\n\n// Function to add a new slot to the filteredFreeSlots array\nfunction addSlot(start, end) {\n    filteredFreeSlots.push({\n        start: start.toISOString(),\n        end: end.toISOString()\n    });\n}\n\n// Loop over all free slots\nfor (const slot of $input.all()) {\n    // Convert the start and end times to Date objects\n    let startDate = new Date(slot.json.start);\n    let endDate = new Date(slot.json.end);\n\n    // If the slot starts and ends on the same day and it's a weekend, skip it\n    if (isWeekend(startDate) && startDate.toDateString() === endDate.toDateString()) {\n        continue;\n    }\n\n    // Split the slot into smaller slots excluding weekends\n    while (startDate < endDate) {\n        if (isWeekend(startDate)) {\n            // Move to the next day if it's a weekend\n            startDate.setDate(startDate.getDate() + 1);\n            startDate.setHours(0, 0, 0, 0);\n            continue;\n        }\n\n        // Calculate the end of the current day\n        const endOfDay = new Date(startDate);\n        endOfDay.setHours(23, 59, 59, 999);\n\n        // Determine the actual end time for the current slot\n        const actualEnd = endOfDay < endDate ? endOfDay : endDate;\n\n        // Add the slot to the filtered free slots\n        addSlot(startDate, actualEnd);\n\n        // Move to the next day\n        startDate = new Date(actualEnd);\n        startDate.setDate(startDate.getDate() + 1);\n        startDate.setHours(0, 0, 0, 0);\n    }\n}\n\n// Return the filtered free slots\nreturn filteredFreeSlots;\n"
      },
      "id": "7c91a691-158b-4798-a17b-9aa4d206edba",
      "name": "Exclude weekend",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2400, 752]
    },
    {
      "parameters": {
        "jsCode": "// Define working hours and timezone\nconst workingHoursStart = $node[\"Define working hours\"].json[\"workingHoursStart\"]; // 8 AM\nconst workingHoursEnd = $node[\"Define working hours\"].json[\"workingHoursEnd\"]; // 6 PM\nconst timezone = $node[\"Set local timezone\"].json[\"timezone\"]; // Pacific Time (PT)\n\n// Initialize an array to store the filtered free slots\nconst filteredFreeSlots = [];\n\n// Function to convert ISO string to a Date object in PT\nfunction toPT(dateString) {\n    return new Date(new Date(dateString).toLocaleString(\"en-US\", { timeZone: timezone }));\n}\n\n// Function to convert a Date object in PT back to ISO string\nfunction toISO(date) {\n    return new Date(date.toISOString()); // Ensuring it remains in UTC format\n}\n\n// Loop over all free slots\nfor (const slot of $(\"Exclude weekend\").all()) {\n    // Convert the start and end times to PT Date objects\n    let startDate = toPT(slot.json.start);\n    let endDate = toPT(slot.json.end);\n\n    // Adjust the slot to exclude non-working hours\n    let adjustedStartDate = new Date(startDate);\n    let adjustedEndDate = new Date(endDate);\n\n    // If the start time is before working hours, set it to the start of working hours\n    if (adjustedStartDate.getHours() < workingHoursStart) {\n        adjustedStartDate.setHours(workingHoursStart, 0, 0, 0);\n    }\n    // If the end time is after working hours, set it to the end of working hours\n    if (adjustedEndDate.getHours() >= workingHoursEnd) {\n        adjustedEndDate.setHours(workingHoursEnd, 0, 0, 0);\n    }\n\n    // If the adjusted start time is before the adjusted end time, add the adjusted slot\n    if (adjustedStartDate < adjustedEndDate) {\n        filteredFreeSlots.push({\n            start: adjustedStartDate.toISOString(),\n            end: adjustedEndDate.toISOString(),\n        });\n    }\n}\n\n// Return the filtered free slots\nreturn filteredFreeSlots;\n"
      },
      "id": "75b474d2-0852-4c2c-8151-484f53cd4996",
      "name": "Exclude non-working hours",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2640, 688]
    },
    {
      "parameters": {
        "jsCode": "// Define the minimum number of hours required each day\nconst minHoursPerDay = $node[\"Set min hours per day\"].json[\"minHoursPerDay\"];\n\n// Initialize an object to store the total working hours for each day\nconst workingHoursPerDay = {};\n\n// Define timezone\nconst timezone = $node[\"Set local timezone\"].json[\"timezone\"]; // Pacific Time (PT)\n\n// Function to convert a date to the specified timezone\nfunction convertToTimezone(date, timeZone) {\n    const offset = date.getTimezoneOffset(); // Get the offset from UTC in minutes\n    const localOffset = new Date(date.getTime() - (offset * 60000)); // Adjust for local time\n    const targetOffset = localOffset.getTimezoneOffset(); // Get target timezone offset\n    const diffOffset = targetOffset - offset; // Calculate difference\n    const targetDate = new Date(localOffset.getTime() + (diffOffset * 60000)); // Apply difference\n    return targetDate;\n}\n\n// Loop over all free slots\nfor (const slot of $(\"Exclude non-working hours\").all()) {\n    // Convert the start and end times to Date objects and then to specified timezone\n    const startDate = convertToTimezone(new Date(slot.json.start), timezone);\n    const endDate = convertToTimezone(new Date(slot.json.end), timezone);\n\n    // Get the date string in YYYY-MM-DD format for the start date\n    const startDateString = startDate.toISOString().split('T')[0];\n\n    // Calculate the duration of the slot in hours\n    const duration = (endDate - startDate) / (1000 * 60 * 60);\n\n    // Add the duration to the respective day\n    if (!workingHoursPerDay[startDateString]) {\n        workingHoursPerDay[startDateString] = 0;\n    }\n    workingHoursPerDay[startDateString] += duration;\n}\n\n// Check if each day has at least the minimum required hours\nlet allDaysHaveMinHours = true;\nfor (const day in workingHoursPerDay) {\n    if (workingHoursPerDay[day] < minHoursPerDay) {\n        allDaysHaveMinHours = false;\n        break;\n    }\n}\n\n// Return the result in the desired format\nreturn { result: allDaysHaveMinHours };\n"
      },
      "id": "601ab963-aec1-4f9c-8090-440a94faeb9d",
      "name": "Ensure at least 8h free each day",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2896, 592]
    },
    {
      "parameters": {
        "mode": "raw",
        "jsonOutput": "={\n \"timeMin\": \"{{ $now.plus(1, 'day').startOf('day').toISO() }}\",\n  \"timeMax\": \"{{ $now.plus(7, 'day').endOf('day').toISO() }}\"\n}\n",
        "options": {}
      },
      "id": "0c391742-cc73-49e5-8dfb-57ece13910c8",
      "name": "Define time window",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.3,
      "position": [1744, 1024],
      "executeOnce": true
    },
    {
      "parameters": {
        "content": "## Define variables\n### Define time range to look, working hours, and min hours to work per day",
        "height": 221,
        "width": 2564
      },
      "id": "40b79558-d321-4141-91e5-acf102863c60",
      "name": "Sticky Note1",
      "type": "n8n-nodes-base.stickyNote",
      "position": [480, 976],
      "typeVersion": 1
    },
    {
      "parameters": {
        "mode": "raw",
        "jsonOutput": "{\n \"workingHoursStart\": 8,\n  \"workingHoursEnd\": 18\n}\n",
        "options": {}
      },
      "id": "b90b1ce1-c3b5-43a9-8c73-a29a854ee313",
      "name": "Define working hours",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.3,
      "position": [2384, 1024],
      "executeOnce": true
    },
    {
      "parameters": {
        "mode": "raw",
        "jsonOutput": "{\n \"minHoursPerDay\": 8\n}\n",
        "options": {}
      },
      "id": "ac33de13-28fe-458f-88c2-441b17d103d8",
      "name": "Set min hours per day",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.3,
      "position": [2816, 1024],
      "executeOnce": true
    },
    {
      "parameters": {
        "mode": "raw",
        "jsonOutput": "{\n \"timezone\": \"America/Los_Angeles\"\n}\n",
        "options": {}
      },
      "id": "d60a2a6c-ee6e-4d36-a289-9524c01de2c2",
      "name": "Set local timezone",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.3,
      "position": [2192, 1024],
      "executeOnce": true
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "calendar-check",
        "responseMode": "lastNode",
        "responseData": "allEntries",
        "options": {
          "rawBody": false
        }
      },
      "id": "ff47381b-41a3-40ed-9cdc-3cdbeceff601",
      "name": "Webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [576, 672],
      "webhookId": "8d0b9ce5-80ca-4260-9766-e03b5dfee892"
    },
    {
      "parameters": {
        "secretPath": "=linguistnow/tokens/{{ $json.body.userEmail }}",
        "additionalFields": {}
      },
      "type": "n8n-nodes-hashi-vault.hashiCorpVault",
      "typeVersion": 1,
      "position": [1312, 592],
      "id": "a36f104c-730a-4753-90b7-47ceaaae7df1",
      "name": "Fetch Token from Vault",
      "credentials": {
        "hashiCorpVaultApi": {
          "id": "eedRjGljfFGhbIlF",
          "name": "HashiCorp Vault account"
        }
      }
    }
  ],
  "pinData": {},
  "connections": {
    "Return free time slots": {
      "main": [
        [
          {
            "node": "Exclude weekend",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check when busy": {
      "main": [
        [
          {
            "node": "List when busy across all calendars",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "List when busy across all calendars": {
      "main": [
        [
          {
            "node": "Return free time slots",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Exclude weekend": {
      "main": [
        [
          {
            "node": "Set local timezone",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Exclude non-working hours": {
      "main": [
        [
          {
            "node": "Set min hours per day",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Define time window": {
      "main": [
        [
          {
            "node": "Check when busy",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Set min hours per day": {
      "main": [
        [
          {
            "node": "Ensure at least 8h free each day",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Set local timezone": {
      "main": [
        [
          {
            "node": "Define working hours",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Define working hours": {
      "main": [
        [
          {
            "node": "Exclude non-working hours",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Stringify calendar list": {
      "main": [
        [
          {
            "node": "Fetch Token from Vault",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Webhook": {
      "main": [
        [
          {
            "node": "Stringify calendar list",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fetch Token from Vault": {
      "main": [
        [
          {
            "node": "Define time window",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": true,
  "settings": {
    "executionOrder": "v1",
    "timeSavedMode": "fixed",
    "timezone": "America/Vancouver",
    "callerPolicy": "workflowsFromSameOwner",
    "availableInMCP": false
  },
  "versionId": "afc543a4-909c-4e69-a7a4-1bc1b33bf504",
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "781f90dfef4c062df5afa0fa93bb6c6add3a04ac970c81606ae17aa08a8d1909"
  },
  "id": "4NnHhRAhAkG0h4Sz",
  "tags": []
}
